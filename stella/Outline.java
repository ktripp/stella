package stella;import java.awt.*;import java.awt.image.BufferedImage;import java.awt.geom.GeneralPath;import java.util.ArrayList;class Outline {	public static Shape getOutline(BufferedImage bi) {		// finds the outline defined by the change in transparency using		int w = bi.getWidth();		int h = bi.getHeight();		boolean[][] outlinePoints = new boolean[w][h];		boolean[][] visited = new boolean[w][h];		Point endingPoint = new Point(0, 0);		ArrayList<Point> q = new ArrayList<Point>();		q.add(new Point(0, 0));		while (!q.isEmpty()) {			Point p = q.remove(0);			if (isTransparent(bi.getRGB(p.x, p.y))) {				outlinePoints[p.x][p.y] = true;				endingPoint = p;			}			else {				if (!visited[p.x][p.y]) {					outlinePoints[p.x][p.y] = false;					if (p.y + 1 < h) q.add(new Point(p.x, p.y + 1));					if (p.x + 1 < w) q.add(new Point(p.x + 1, p.y));					if (p.y - 1 >= 0) q.add(new Point(p.x, p.y - 1));					if (p.x - 1 >= 0) q.add(new Point(p.x - 1, p.y));				}			}			visited[p.x][p.y] = true;		}				// construct the GeneralPath		GeneralPath gp = new GeneralPath(GeneralPath.WIND_EVEN_ODD);		visited = new boolean[w][h];		Point current = endingPoint;		Point next = null;				gp.moveTo(current.x, current.y);		while ((next = findNeighbor(current, visited, outlinePoints, w, h)) != null) {			visited[next.x][next.y]= true;			gp.lineTo(next.x, next.y);			current = next;		}				// draw the info box centered below the image		gp.moveTo(w/2, h);		gp.lineTo(w/2, h);		gp.lineTo(w/2 - 110, h);		gp.lineTo(w/2 - 110, h + 50);		gp.lineTo(w/2 + 110, h + 50);		gp.lineTo(w/2 +  110, h);		gp.lineTo(w/2, h);		gp.closePath();				return gp;	}		// finds a valid neighbor for the bfs	public static Point findNeighbor(Point p, boolean[][] visited, boolean[][] outlinePoints, int w, int h) {		int[] offsets = {-1, 0, 1};		for (int xOff : offsets) {			for (int yOff : offsets) {				int x = p.x + xOff;				int y = p.y + yOff;				if (x < w && x >= 0 && y < h && y >= 0) {					if (!visited[x][y] && outlinePoints[x][y]) {						return new Point(x, y);					}				}			}		}		return null;	}		// Tests transparency	public static boolean isTransparent(int pixel) {		int alpha = (pixel >> 24) & 0xFF; 		return alpha == 255;	}		// Prints the outline defined by the transition from transparent to opaque	public static void printOutline(BufferedImage img) {		for (int i = 0; i < img.getHeight(); i++) {			for (int j = 0; j < img.getWidth(); j++) {				if (isTransparent(img.getRGB(j, i)))					System.out.print("*");				else					System.out.print(" ");			}			System.out.println();		}	}}